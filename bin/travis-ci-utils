#!/usr/bin/env python3.6
##
# Rindeal's Suite of Helpers and Utilities for Travis CI
#
# just a bunch of helper functions to make life easier
#
# Copyright (C) 2018  Jan Chren (rindeal)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

import argparse
import textwrap
import typing
import sys
import pathlib
import tempfile

# sys.path.insert(0, ".")  # DEBUG
from rindeal.travis_ci._pkg_metadata import metadata
from rindeal.travis_ci import Fold, Timer

SubParserType = type(argparse.ArgumentParser().add_subparsers())


class SubCmd:
	name: str

	def __init__(self, cmd_name: str, sub_parser: SubParserType) -> None:
		raise NotImplementedError

	def handle(self, args: argparse.Namespace) -> None:
		raise NotImplementedError


class SubCmdFold(SubCmd):
	name = "fold"

	def __init__(self, cmd_name, sub_parser):
		parser = sub_parser.add_parser(cmd_name)
		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', help='Start fold', action='store_true')
		group.add_argument('-end', help='End fold', action='store_true')
		parser.add_argument('--desc', help='Description of the fold, usable only with `-start`', nargs=1)
		parser.add_argument('TAG', help='Tag of the fold', nargs=1)

	def handle(self, args) -> None:
		tag = args.TAG[0]

		if args.start:
			self._handle_start(args, tag)
		elif args.end:
			self._handle_end(args, tag)
		else:
			raise Exception('args error')

	def _handle_start(self, args, tag) -> None:
		desc = args.desc[0] if args.desc else None
		fold = Fold(tag=tag, desc=desc, stream=sys.stdout)
		bytes_written = fold.start()

		if bytes_written <= 0:
			raise Exception("error, no bytes written")

	def _handle_end(self, args, tag) -> None:
		fold = Fold(tag=tag, started=True, stream=sys.stdout)
		bytes_written = fold.end()

		if bytes_written <= 0:
			raise Exception("error, no bytes written")


class SubCmdTimer(SubCmd):
	name = "timer"
	_delimiter = ':'
	_ipc_id_prefix = '__TRAVIS_CI_TIMER_'

	def __init__(self, cmd_name, sub_parser):
		parser = sub_parser.add_parser(cmd_name)
		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', '--start', help='start the timer', action='store_true')
		group.add_argument('-end', '--end', help='end the timer', action='store_true')
		parser.add_argument('ID', help='ID of the timer', action='store', nargs=1)

	def handle(self, args):
		tmpfile = pathlib.PosixPath(
			tempfile.gettempdir(),
			tempfile.gettempprefix() + "." + self._ipc_id_prefix + "." + args.ID[0]
		)

		if args.start:
			self._handle_start(tmpfile)
		elif args.end:
			self._handle_end(tmpfile)
		else:
			raise Exception('args error')

	def _handle_start(self, tmpfile: pathlib.PosixPath) -> None:
		timer = Timer(stream=sys.stdout)
		bytes_written = timer.start()

		if bytes_written <= 0:
			raise Exception("error, no bytes written")

		timer_id = timer.get_id()
		timer_start_time = timer.get_start_time()

		# >> create and write timer object
		start_obj = f"{timer_id}{self._delimiter}{timer_start_time}"
		with tmpfile.open('w+') as f:
			f.write(start_obj)

	def _handle_end(self, tmpfile: pathlib.PosixPath) -> None:
		# >> read timer object
		if not tmpfile.exists():
			raise Exception('no timer with this id found')
		with tmpfile.open('r') as f:
			start_obj = f.read()
		tmpfile.unlink()

		# >> parse timer object
		timer_id, timer_start_time = start_obj.split(self._delimiter)
		timer_start_time = int(timer_start_time)

		timer = Timer(stream=sys.stdout, timer_id=timer_id, start_time=timer_start_time)
		bytes_written = timer.end()
		if bytes_written <= 0:
			raise Exception("error, no bytes written")


class Main:
	args: argparse.Namespace

	sub_cmds: typing.Dict[str, SubCmd] = {}
	sub_cmd_arg_name = 'sub_cmd_name'

	def __init__(s):
		pass

	def main(self):
		parser = self.create_main_parser()
		self.add_subparsers(parser)
		self.args = parser.parse_args()
		sub_cmd_name = getattr(self.args, self.sub_cmd_arg_name)
		if sub_cmd_name:
			getattr(self.sub_cmds[sub_cmd_name], 'handle')(self.args)

	@staticmethod
	def create_main_parser() -> argparse.ArgumentParser:
		parser = argparse.ArgumentParser(
			description="Travis CI Utilities Suite",
			formatter_class=argparse.RawDescriptionHelpFormatter,
		)
		parser.add_argument(
			'-v', '--version',
			action='version',
			version=textwrap.dedent(
				f"""
				%(prog)s {metadata.version}

				Copyright 2018 {metadata.author}
				License GPLv3: GNU GPL version 3 <http://gnu.org/licenses/gpl.html>
				This is free software: you are free to change and redistribute it.
				There is NO WARRANTY, to the extent permitted by law.
				"""
			)
		)

		return parser

	def add_subparsers(self, main_parser):
		cmd_parser: SubParserType = main_parser.add_subparsers(
			help='Pick one of the subcommands',
			dest=self.sub_cmd_arg_name,
		)

		sub_cmd_cls_prefix = "SubCmd"
		sub_cmd_classes = {
			cls.name: cls
			for name, cls in globals().items()
			if name.startswith(sub_cmd_cls_prefix) and len(name) > len(sub_cmd_cls_prefix)
		}

		for cmd_name, cmd_cls in sub_cmd_classes.items():
			self.sub_cmds[cmd_name] = cmd_cls(sub_parser=cmd_parser, cmd_name=cmd_name)


if __name__ == "__main__":
	m = Main()
	m.main()
else:
	exit("this script is not importable")
