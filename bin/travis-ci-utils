#!/usr/bin/env python3
##
# Copyright (C) 2018  Jan Chren (rindeal)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

import argparse
import textwrap
import typing
import sys
import pathlib
import tempfile
import os

if os.path.exists("rindeal/travis_ci/utils"):
	sys.path.insert(0, ".")
from rindeal.travis_ci.utils import Fold, Time
from rindeal.travis_ci.utils._pkg_metadata import metadata


SubParserType = type(argparse.ArgumentParser().add_subparsers())


class SubCmd:
	name: str
	_parser: argparse.ArgumentParser = None
	_args: argparse.Namespace = None

	def __init__(self, sub_parser: SubParserType) -> None:
		raise NotImplementedError

	def handle(self, parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:
		self._parser = parser
		self._args = args


class SubCmdFold(SubCmd):
	name = "fold"
	_bytes_written: int = 0

	def __init__(self, sub_parser):
		parser = sub_parser.add_parser(self.name)
		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', help='Start a fold', action='store_true')
		group.add_argument('-end', help='End a fold', action='store_true')
		group.add_argument('-desc', help='Print description of a fold', metavar='DESC', nargs=1)
		parser.add_argument(
			'--desc',
			help='Description of the fold, usable only with `-start`',
			nargs=1,
			dest="description"
		)
		parser.add_argument('TAG', help='Tag of the fold; requires for `-start`/`-end`', nargs="?")

	def handle(self, parser: argparse.ArgumentParser, args) -> None:
		super().handle(parser, args)

		if args.start:
			self._handle_start(args.TAG, args.description[0] if args.description else "")
		elif args.end:
			self._handle_end(args.TAG)
		elif args.desc:
			self._handle_desc(args.desc[0])
		else:
			self._parser.error("invalid args, this shouldn't happen")

		if self._bytes_written <= 0:
			self._parser.error("no bytes written")

	def _handle_start(self, tag, desc: str) -> None:
		fold = Fold(tag=tag, desc=desc, stream=sys.stdout)
		self._bytes_written = fold.start()

	def _handle_end(self, tag) -> None:
		fold = Fold(tag=tag, started=True, stream=sys.stdout)
		self._bytes_written = fold.end()

	def _handle_desc(self, desc: str) -> None:
		fold = Fold(tag="NOT.USED", started=True, stream=sys.stdout)
		self._bytes_written = fold.desc(desc)


class SubCmdTime(SubCmd):
	name = "time"
	_bytes_written: int = 0

	_delimiter = ':'
	_ipc_id_prefix = '__TRAVIS_CI_TIME_'

	def __init__(self, sub_parser):
		parser = sub_parser.add_parser(self.name)
		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', '--start', help='Start timing', action='store_true')
		group.add_argument('-end', '--end', help='End timing', action='store_true')
		parser.add_argument('ID', help='ID of the timer', action='store', nargs=1)

	def handle(self, parser, args):
		super().handle(parser, args)

		tmpfile = pathlib.PosixPath(
			tempfile.gettempdir(),
			tempfile.gettempprefix() + "." + self._ipc_id_prefix + "." + self._args.ID[0]
		)

		if args.start:
			self._handle_start(tmpfile)
		elif args.end:
			self._handle_end(tmpfile)
		else:
			self._parser.error("invalid args, this shouldn't happen")

		if self._bytes_written <= 0:
			self._parser.error("no bytes written")

	def _handle_start(self, tmpfile: pathlib.PosixPath) -> None:
		timer = Time(stream=sys.stdout)
		self._bytes_written = timer.start()

		timer_id = timer.get_id()
		timer_start_time = timer.get_start_time()

		# >> create and write timer object
		start_obj = f"{timer_id}{self._delimiter}{timer_start_time}"
		with tmpfile.open('w+') as f:
			f.write(start_obj)

	def _handle_end(self, tmpfile: pathlib.PosixPath) -> None:
		# >> read timer object
		if not tmpfile.exists():
			self._parser.error('no timer with this id found')
		with tmpfile.open('r') as f:
			start_obj = f.read()
		tmpfile.unlink()

		# >> parse timer object
		timer_id, timer_start_time = start_obj.split(self._delimiter)
		timer_start_time = int(timer_start_time)

		timer = Time(stream=sys.stdout, timer_id=timer_id, start_time=timer_start_time)
		self._bytes_written = timer.end()


class Main:
	sub_cmds: typing.Dict[str, SubCmd] = {}
	sub_cmd_arg_name = 'sub_cmd_name'

	def main(self):
		parser = self.create_main_parser()
		self.add_subparsers(parser)

		args: argparse.Namespace = parser.parse_args()

		sub_cmd_name = getattr(args, self.sub_cmd_arg_name)
		if sub_cmd_name:
			sub_cmd_obj = self.sub_cmds[sub_cmd_name]
			handle_method = getattr(sub_cmd_obj, 'handle')
			handle_method(parser, args)
		else:
			parser.print_usage()

	@staticmethod
	def create_main_parser() -> argparse.ArgumentParser:
		parser = argparse.ArgumentParser(
			description=metadata.short_description,
			formatter_class=argparse.RawDescriptionHelpFormatter,
		)
		parser.add_argument(
			'-v', '--version',
			action='version',
			version=textwrap.dedent(
				f"""
				%(prog)s {metadata.version}

				Copyright 2018 {metadata.author}
				License GPLv3: GNU GPL version 3 <http://gnu.org/licenses/gpl.html>
				This is free software: you are free to change and redistribute it.
				There is NO WARRANTY, to the extent permitted by law.
				"""
			)
		)

		return parser

	def add_subparsers(self, main_parser):
		cmd_parser: SubParserType = main_parser.add_subparsers(
			help='Pick one of the subcommands',
			dest=self.sub_cmd_arg_name,
		)

		sub_cmd_cls_prefix = "SubCmd"
		sub_cmd_classes = {
			cls.name: cls
			for name, cls in globals().items()
			if name.startswith(sub_cmd_cls_prefix) and len(name) > len(sub_cmd_cls_prefix)
		}

		for cmd_name, cmd_cls in sub_cmd_classes.items():
			self.sub_cmds[cmd_name] = cmd_cls(sub_parser=cmd_parser)


if __name__ == "__main__":
	m = Main()
	m.main()
else:
	exit("this script is not importable")
