#!/usr/bin/env python3
##
# Copyright (C) 2018  Jan Chren (rindeal)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

import argparse
import textwrap
import typing
import sys
import pathlib
import tempfile
import os
import pickle

if os.path.exists("rindeal/travis_ci/utils"):
	sys.path.insert(0, ".")
from rindeal.travis_ci.utils import Fold, Time
from rindeal.travis_ci.utils._pkg_metadata import metadata


SubParserType = type(argparse.ArgumentParser().add_subparsers())


class SubCmd:
	_CLS_NAME_PREFIX = "SubCmd"

	_parser: argparse.ArgumentParser = None
	_args: argparse.Namespace = None

	def __init__(self, sub_parser: SubParserType) -> None:
		raise NotImplementedError

	def handle(self, parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:
		self._parser = parser
		self._args = args

	def get_name(self):
		return self.__class__.__name__[len(self._CLS_NAME_PREFIX):].lower()

	def _get_parser(self, sub_parser: SubParserType):
		return sub_parser.add_parser(self.get_name())


class SubCmdFold(SubCmd):
	_bytes_written: int = 0

	def __init__(self, sub_parser):
		parser = self._get_parser(sub_parser)

		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', help='Start a fold', action='store_true')
		group.add_argument('-end',   help='End a fold', action='store_true')
		group.add_argument('-desc',  help='Print description of a fold', metavar='DESC', nargs=1)

		parser.add_argument(
			'--desc',
			help='Description of the fold, usable only with `-start`',
			nargs=1,
			dest="description"
		)
		parser.add_argument('TAG', help='Tag of the fold; requires for `-start`/`-end`', nargs="?")

	def handle(self, parser: argparse.ArgumentParser, args) -> None:
		super().handle(parser, args)

		if args.start:
			self._handle_start(args.TAG, args.description[0] if args.description else "")
		elif args.end:
			self._handle_end(args.TAG)
		elif args.desc:
			self._handle_desc(args.desc[0])
		else:
			self._parser.error("invalid args, this shouldn't happen")

		if self._bytes_written <= 0:
			self._parser.error("no bytes written")

	def _handle_start(self, tag, desc: str) -> None:
		fold = Fold(tag=tag, desc=desc, stream=sys.stdout)
		self._bytes_written = fold.start()

	def _handle_end(self, tag) -> None:
		fold = Fold(tag=tag, started=True, stream=sys.stdout)
		self._bytes_written = fold.end()

	def _handle_desc(self, desc: str) -> None:
		fold = Fold(tag="NOT.USED", started=True, stream=sys.stdout)
		self._bytes_written = fold.desc(desc)


class SubCmdTime(SubCmd):
	_IPC_ID_PREFIX = '__TRAVIS_CI_TIME_'

	_bytes_written: int = 0
	_tmpfile: pathlib.PosixPath = None

	def __init__(self, sub_parser):
		parser = self._get_parser(sub_parser)

		group = parser.add_mutually_exclusive_group(required=True)
		group.add_argument('-start', '--start', help='Start timing', action='store_true')
		group.add_argument('-end',   '--end',   help='End timing', action='store_true')

		parser.add_argument('ID', help='ID of the timer', nargs=1)

	def handle(self, parser, args):
		super().handle(parser, args)

		self._tmpfile = pathlib.PosixPath(
			tempfile.gettempdir(),
			tempfile.gettempprefix() + "." + self._IPC_ID_PREFIX + "." + self._args.ID[0]
		)

		if args.start:
			self._handle_start()
		elif args.end:
			self._handle_end()
		else:
			self._parser.error("invalid args, this shouldn't happen")

		if self._bytes_written <= 0:
			self._parser.error("no bytes written")

	def _handle_start(self) -> None:
		timer = Time(stream=sys.stdout)
		self._bytes_written = timer.start()

		start_obj = {
			'id': timer.get_id(),
			'start_time': timer.get_start_time()
		}

		with self._tmpfile.open('wb+') as f:
			pickle.dump(start_obj, f)

	def _handle_end(self) -> None:
		# >> check
		if not self._tmpfile.exists():
			self._parser.error('no timer with this id found')

		# >> load
		with self._tmpfile.open('rb') as f:
			start_obj = pickle.load(f)

		# >> clean
		self._tmpfile.unlink()

		# >> process
		timer = Time(stream=sys.stdout, timer_id=start_obj['id'], start_time=start_obj['start_time'])
		self._bytes_written = timer.end()


class Main:
	sub_cmds: typing.Dict[str, SubCmd] = {}
	sub_cmd_arg_name = 'sub_cmd_name'

	def main(self):
		parser = self._create_main_parser()
		self._add_subparsers(parser)

		args: argparse.Namespace = parser.parse_args()

		sub_cmd_name = getattr(args, self.sub_cmd_arg_name)
		if sub_cmd_name:
			sub_cmd_obj = self.sub_cmds[sub_cmd_name]
			handle_method = getattr(sub_cmd_obj, 'handle')
			return handle_method(parser, args)
		else:
			return parser.print_usage()

	def _create_main_parser(self) -> argparse.ArgumentParser:
		parser = argparse.ArgumentParser(
			description=metadata.short_description,
			formatter_class=argparse.RawDescriptionHelpFormatter,
		)
		parser.add_argument(
			'-v', '--version',
			action='version',
			version=textwrap.dedent(
				f"""
				%(prog)s {metadata.version}

				Copyright 2018 {metadata.author}
				License GPLv3: GNU GPL version 3 <http://gnu.org/licenses/gpl.html>
				This is free software: you are free to change and redistribute it.
				There is NO WARRANTY, to the extent permitted by law.
				"""
			)
		)

		return parser

	def _add_subparsers(self, main_parser):
		cmd_parser: SubParserType = main_parser.add_subparsers(
			help='Pick one of the subcommands',
			dest=self.sub_cmd_arg_name,
		)

		for name, cls in globals().items():
			if not (hasattr(cls, "__bases__") and SubCmd in cls.__bases__):
				continue
			obj: SubCmd = cls(sub_parser=cmd_parser)
			cmd_name = obj.get_name()
			self.sub_cmds[cmd_name] = obj


if __name__ == "__main__":
	m = Main()
	exit(m.main())
else:
	exit("this script is not importable")
